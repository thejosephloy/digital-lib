$date
	Fri Apr 28 13:07:05 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module combinational_tb $end
$var wire 4 ! b [3:0] $end
$var reg 4 " a0 [3:0] $end
$var reg 4 # a1 [3:0] $end
$var reg 4 $ a2 [3:0] $end
$var reg 4 % a3 [3:0] $end
$var reg 4 & a4 [3:0] $end
$var reg 4 ' a5 [3:0] $end
$var reg 6 ( s [5:0] $end
$scope module mux6 $end
$var wire 4 ) a0 [3:0] $end
$var wire 4 * a1 [3:0] $end
$var wire 4 + a2 [3:0] $end
$var wire 4 , a3 [3:0] $end
$var wire 4 - a4 [3:0] $end
$var wire 4 . a5 [3:0] $end
$var wire 4 / b [3:0] $end
$var wire 6 0 s [5:0] $end
$var wire 4 1 bb [3:0] $end
$var wire 4 2 ba [3:0] $end
$scope module ma $end
$var wire 4 3 a0 [3:0] $end
$var wire 4 4 a1 [3:0] $end
$var wire 4 5 a2 [3:0] $end
$var wire 4 6 b [3:0] $end
$var wire 3 7 s [2:0] $end
$upscope $end
$scope module mb $end
$var wire 4 8 a0 [3:0] $end
$var wire 4 9 a1 [3:0] $end
$var wire 4 : a2 [3:0] $end
$var wire 4 ; b [3:0] $end
$var wire 3 < s [2:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
bx #
bx "
bx !
$end
#5000
b0xxx !
b0xxx /
b0xxx 2
b0xxx 6
b0xx 1
b0xx ;
b110 '
b110 )
b110 3
b101 &
b101 *
b101 4
b100 %
b100 +
b100 5
b11 $
b11 ,
b11 8
b10 #
b10 -
b10 9
b1 "
b1 .
b1 :
#10000
b110 !
b110 /
b110 2
b110 6
b0 1
b0 ;
b1 7
b0 <
b1 (
b1 0
#15000
b101 !
b101 /
b101 2
b101 6
b10 7
b10 (
b10 0
#20000
b100 !
b100 /
b100 2
b100 6
b100 7
b100 (
b100 0
#25000
b11 !
b11 /
b11 1
b11 ;
b0 2
b0 6
b0 7
b1 <
b1000 (
b1000 0
#30000
b10 !
b10 /
b10 1
b10 ;
b10 <
b10000 (
b10000 0
#35000
b1 !
b1 /
b1 1
b1 ;
b100 <
b100000 (
b100000 0
#40000
